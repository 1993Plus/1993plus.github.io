<!DOCTYPE html>


  <html class="light page-post">


<head>
  <meta charset="utf-8">
  
  <title>LVS 的调度算法 | Weidong</title>

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
    <meta name="keywords" content="LVS,LVS Scheduling," />
  

  <meta name="description" content="LVS 连接调度算法 IPVS 在内核中的负载均衡调度是以连接为粒度的。在 HTTP 协议（非持久）中，每个对象从 WEB 服务器上获取都需要建立一个 TCP 连接，同一用户的不同请求会被调度到不同的服务器上，所以这种细粒度的调度在一定程度上可以避免单个用户访问的突发性引起服务器间的负载不均衡。 在内核中的连接调度算法上，IPVS 已经实现了一下八种调度算法：  轮叫调度（Round-Robin">
<meta name="keywords" content="LVS,LVS Scheduling">
<meta property="og:type" content="article">
<meta property="og:title" content="LVS 的调度算法">
<meta property="og:url" content="http://www.weidong.io/2017/10/27/lvs-scheduling/index.html">
<meta property="og:site_name" content="Weidong">
<meta property="og:description" content="LVS 连接调度算法 IPVS 在内核中的负载均衡调度是以连接为粒度的。在 HTTP 协议（非持久）中，每个对象从 WEB 服务器上获取都需要建立一个 TCP 连接，同一用户的不同请求会被调度到不同的服务器上，所以这种细粒度的调度在一定程度上可以避免单个用户访问的突发性引起服务器间的负载不均衡。 在内核中的连接调度算法上，IPVS 已经实现了一下八种调度算法：  轮叫调度（Round-Robin">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2017-10-27T09:44:01.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="LVS 的调度算法">
<meta name="twitter:description" content="LVS 连接调度算法 IPVS 在内核中的负载均衡调度是以连接为粒度的。在 HTTP 协议（非持久）中，每个对象从 WEB 服务器上获取都需要建立一个 TCP 连接，同一用户的不同请求会被调度到不同的服务器上，所以这种细粒度的调度在一定程度上可以避免单个用户访问的突发性引起服务器间的负载不均衡。 在内核中的连接调度算法上，IPVS 已经实现了一下八种调度算法：  轮叫调度（Round-Robin">

  

  
    <link rel="icon" href="/favicon.ico">
  

  <link href="/css/styles.css?v=c114cbe6" rel="stylesheet">


  
    <link rel="stylesheet" href="/css/personal-style.css">
  

  

  
  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?57e94d016e201fba3603a8a2b0263af0";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>


  
  <script type="text/javascript">
	(function(){
	    var bp = document.createElement('script');
	    var curProtocol = window.location.protocol.split(':')[0];
	    if (curProtocol === 'https') {
	        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
	    }
	    else {
	        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
	    }
	    var s = document.getElementsByTagName("script")[0];
	    s.parentNode.insertBefore(bp, s);
	})();
  </script>



  
    <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  

  
    <link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.3.0/css/font-awesome.min.css">
  
</head>

<body>


  
    <span id="toolbox-mobile" class="toolbox-mobile">盒子</span>
  

  <div class="post-header CENTER">
   
  <div class="toolbox">
    <a class="toolbox-entry" href="/">
      <span class="toolbox-entry-text">盒子</span>
      <i class="icon-angle-down"></i>
      <i class="icon-home"></i>
    </a>
    <ul class="list-toolbox">
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/archives/"
            rel="noopener noreferrer"
            target="_self"
            >
            博客
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/category/"
            rel="noopener noreferrer"
            target="_self"
            >
            分类
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/tag/"
            rel="noopener noreferrer"
            target="_self"
            >
            标签
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/link/"
            rel="noopener noreferrer"
            target="_self"
            >
            友链
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/about/"
            rel="noopener noreferrer"
            target="_self"
            >
            关于
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/search/"
            rel="noopener noreferrer"
            target="_self"
            >
            搜索
          </a>
        </li>
      
    </ul>
  </div>


</div>




<div class="content content-post CENTER">
   <article id="post-lvs-scheduling" class="article article-type-post" itemprop="blogPost">
  <header class="article-header">
    <h1 class="post-title">LVS 的调度算法</h1>

    <div class="article-meta">
      <span>
        <i class="icon-calendar"></i>
        <span>2017.10.27</span>
      </span>

      
        <span class="article-author">
          <i class="icon-user"></i>
          <span>Weidong</span>
        </span>
      

      
  <span class="article-category">
    <i class="icon-list"></i>
    <a class="article-category-link" href="/categories/LVS/">LVS</a>
  </span>



      
        <span>
          <i class="icon-comment"></i>
          <a href="http://www.weidong.io/2017/10/27/lvs-scheduling/#disqus_thread"></a>
        </span>
      

      
      <i class="fa fa-eye"></i> 
        <span id="busuanzi_container_page_pv">
           &nbsp热度 <span id="busuanzi_value_page_pv">
           <i class="fa fa-spinner fa-spin"></i></span>℃
        </span>
      

      
      
    </div>
  </header>

  <div class="article-content">
    
      <p><strong>LVS 连接调度算法</strong></p>
<p>IPVS 在内核中的负载均衡调度是以连接为粒度的。在 HTTP 协议（非持久）中，每个对象从 WEB 服务器上获取都需要建立一个 TCP 连接，同一用户的不同请求会被调度到不同的服务器上，所以这种细粒度的调度在一定程度上可以避免单个用户访问的突发性引起服务器间的负载不均衡。</p>
<p>在内核中的连接调度算法上，IPVS 已经实现了一下八种调度算法：</p>
<ul>
<li><strong>轮叫调度（Round-Robin Scheduling）</strong></li>
</ul>
<p>轮叫调度（Round-Robin Scheduling）算法就是以轮叫的方式依次将请求调度到不同的服务器。优点是简洁，它不需要记录当前所有连接的状态，所以它是一种无状态调度。</p>
<p>在系统实现时，还引入了一个额外的条件，当服务器的权值为零时，表示该服务器不可用而不被调度。这样做的目的是将服务器切出服务（如屏蔽服务器故障和系统维护），同时与其它加权算法保持一致。</p>
<p>轮叫调度算法假设所有服务器处理性能均相同，不管服务器的当前连接数和响应速度。该算法相对简单，不适用于服务器组处理性能不一的情况，而且当请求服务时间变化较大时，轮叫调度算法容易导致服务器间的负载不均衡。</p>
<p>虽然 Round-Robin DNS 方法也是以轮叫调度的方式将一个域名解析到多个 IP 地址，但轮叫 DNS 方法的调度粒度是基于每个域名服务器的，域名服务器对域名解析的缓存会妨碍轮叫解析域名生效，这会导致服务器间负载的严重不均衡。IPVS 轮叫调度算法的粒度是基于每个连接的，同一用户的不同连接会被调度到不同的服务器上，所以这种粒度的轮叫调度要比 DNS 的轮叫调度优越很多。</p>
<ul>
<li><strong>加权轮叫调度（Weighted Round-Robin Scheduling）</strong></li>
</ul>
<p>加权轮叫调度（Weighted Round-Robin Scheduling）算法可以解决服务器间新能不易的情况，它用相应的权值表示服务器的处理性能，服务器的确实权值为 1 。假设服务器 A 的权值为 1 ，B 的权值为 2 ，则表示服务器 B 的处理性能是 A 的两倍。加权轮叫调度算法是按权值的高低和轮叫方式分配请求到各服务器。权值高的服务器先收到连接，权值高的服务器比权值低的服务器处理更多的连接，相同权值的服务器处理相同数目的连接数。</p>
<p>例如，有三个服务器 A、B、C，权值分别为 4、3、2，则在一个调度周期内调度序列为 AABABCABC。加权轮叫调度算法还是比较简单和高效。当请求的服务器时间变化很大，单独的加权轮叫调度算法依然会导致服务器间的负载不均衡。</p>
<p>当服务器权值为零时，该服务器将不被调度；当所有服务器的权值为零，则没有任何服务器可用，算法返回 NULL，所有的新连接都会被丢掉。加权轮叫调度也不需要记录当前所有连接的状态，所以它也是一种无状态调度。</p>
<ul>
<li><strong>最小连接调度（Least-Connection Scheduling）</strong></li>
</ul>
<p>最小连接调度（Least-Connection Scheduling）算法是吧新的连接请求分配到当前连接数最小的服务器。最小连接调度是一种动态调度算法，它通过服务器当前所活跃的连接数来估计服务器的负载情况。调度器需要记录各个服务器已建立的连接数目，当一个请求被调度到某台服务器，其连接数加 1；当连接终止或超时，其连接数减 1。</p>
<p>在系统实现时，也引入的当服务器的权值为零时，表示该服务器不可用而不被调度。</p>
<p>当各个服务器有相同的处理性能时，最小连接调度算法能把负载变化大的请求分布平滑到各个服务器上，所有处理视角比较长的请求不可能被发送到同一台服务器上。但是，当各个服务器的处理能力不同时，该算法并不理想，因为 TCP 连接处理请求后会进入 TIME_WAIT 状态，TCP 的 TIME_WAIT 一般为 2 分钟，此时连接还占用服务器的资源，所以会出现这种情形，性能高的服务器已处理所收到的连接，连接处于 TIME_WAIT 状态，而性能低的服务器已经忙于处理所收到的连接，还不断地收到新的连接请求。</p>
<ul>
<li><strong>加权最小连接调度（Weighted Least-Connection Scheduling）</strong></li>
</ul>
<p>加权最小连接调度（Weighted Least-Connection Scheduling）算法是最小连接调度的超集，各个服务器用相应的权值表示其处理性能。服务器的缺省权值为 1，系统管理员可以动态的设置服务器的权值。加权最小连接调度在调度新连接是尽可能使服务器的已建立连接数和其权值成比例。</p>
<ul>
<li><strong>基于局部性的最少链接调度（Locality-Based Least Connection Schduling）</strong></li>
</ul>
<p>基于局部性的最少链接调度（Locality-Based Least Connection Scheduling，简称 LBLC）算法是针对请求报文的目标 IP 地址的负载均衡调度，目前主要用于 Cache 集群系统，因为在 Cache 集群中客户请求报文的目标  IP 地址是变化的。假设任何后端服务器都可以处理任一请求，算法的设计目标是在服务器的负载基本平衡情况下，将相同目标 IP 地址的请求调度到同一台服务器，来提高各个服务器的访问局部性和主存 Cache 命中率。</p>
<p>此外，对目标节点 IP 要进行周期性的垃圾回收（Garbage Collection），将过期的目标 IP 地址到服务器关联性进行回收。过期的关联项是指哪些当前时间（实现时采用系统时钟节拍数 jiffies）减去最近使用时间超过设定过期时间的关联项，系统缺省的设定过期时间为 24 小时。</p>
<ul>
<li><strong>带复制的基于局部性最少链接调度（Locality-Based Least Connection with Replication Scheduling）</strong></li>
</ul>
<p>带复制的基于局部性最少链接调度（Locality-Based Least Connection with Replication Scheduling，简称 LBLCR）算法也是针对目标 IP 地址的负载均衡，目前主要用户 Cache 集群系统。它与 LBLC 算法的不同之处是它要维护从一个目标 IP 地址到一组服务器的映射，而 LBLC 算法维护从一个目标 IP 地址到一台服务器的映射。对于一个“热门”站点的服务请求，一台 Cache 服务器可能会忙不过来处理这些请求。这时，LBLC 调度算法会从所有的 Cache 服务器中按“最小连接”原则选出一台服务器，映射该“热门”站点到 Cache 服务器（服务器集合），当该“热门”站点的请求负载增加时，会增加集合里的 Cache 服务器，来处理不对增长的负载；当该“热门”站点的请求负载降低时，会减少集合里 Cache 服务器的数目。这样，该“热门”站点的映像不太可能出现在所有 Cache 服务器上，从而提高 Cache 集群系统的使用效率。</p>
<p>LBLCR 算法先根据请求的目标 IP 地址找出该目标 IP 地址对应的服务器组；按“最小连接” 原则从该服务器组中选出一台服务器，若服务器没有超载，将请求发送到该服务器；若该服务器超载，则按“最小连接”原则从整个集群中选出一台服务器，将该服务器加入到服务器组中，将请求发送带该服务器。同时，当服务器组有一段时间没有被修改，将最忙的服务器从服务器组中删除，以降低复制的程度。</p>
<p>此外，对目标节点 IP 要进行周期性的垃圾回收（Garbage Collection），将过期的目标 IP 地址到服务器关联性进行回收。过期的关联项是指哪些当前时间（实现时采用系统时钟节拍数 jiffies）减去最近使用时间超过设定过期时间的关联项，系统缺省的设定过期时间为 24 小时。</p>
<ul>
<li><strong>目标地址散列调度（Destination Hashting Scheduling）</strong></li>
</ul>
<p>目标地址散列调度（Destination Hashing Scheduling）算法也是针对目标 IP 地址的负载均衡，但它是一种静态映射算法，通过一个散列（Hash）函数将一个目标 IP 地址映射到一台服务器。</p>
<p>目标地址散列调度算法先根据请求的目标 IP 地址，作为散列键（Hash Key）从静态分配的散列表找出对应的服务器，若该服务器是可用的且为超载，将请求发送到该服务器，否则返回空。</p>
<ul>
<li><strong>源地址散列调度（Source Hashing Scheduling）</strong></li>
</ul>
<p>源地址散列调度（Source Hashing Scheduling）算法正好与目标地址散列调度算法相反，它根据请求的源 IP 地址，作为散列键（Hash Key）从静态分配的散列表中找出对应的服务器，若该服务器是可用的且为超载，将请求发送到该服务器，否则返回空。它采用的散列函数与目标地址散列调度算法相同。它的算法流程与目标地址散列调度算法基本相似，除了将请求的目标 IP 地址换成请求的源 IP 地址。</p>
<p>在实际应用中，源地址散列调度和目标地址散列调度可以结合使用在防火墙集群中，他们可以保证整合系统的唯一出入口 。</p>
<p><strong>动态反馈负载均衡算法</strong></p>
<p>动态反馈负载均衡算法考虑到实时负载和响应情况，不对调整服务器间处理请求的比例，来避免有些服务器超载依然收到大量请求，从而提高整合系统的吞吐量。该算法在负载调度器上运行了一个 Monitor Daemon 进程，Monitor Daemon 来监视和收集各个服务器的负载信息。Monitor Daemon 可根据多个负载信息算出一个综合负载值。Monitor Daemon 将各个服务器的综合负载值和当前权值算出一组新的权值，若新权值和当前权值的差值大于设定的阀值，Monitor Daemon 将改服务器的权值设置到内核中的 IPVS 调度中，而在内核中连接调度一般采用加权轮叫调度算法或者加权最小连接调度算法</p>
<p><strong>连接调度</strong></p>
<p>当客户通过 TCP 连接访问网络时，服务所需的实际和所要消耗的计算资源是千差万别的，它依赖于很多因素。例如，它依赖于请求的服务类型、当前网络带宽的情况、以及当前服务器资源利用情况。一些负载比较重的请求需要进行计算密集的查询、数据库访问、很长响应数据流；而负载比较轻的请求往往只需要读一个 HTML 页面或者进行很简单的计算。</p>
<p>请求处理时间的千差万别可能会导致服务器利用的倾斜（Skew），即服务器间的负载不平衡。例如，有一个 WEB 页面有 A、B、C 和 D 文件，其中 D 是大图像文件，浏览器需要连理四个连接来取这些文件。当多个用户通过浏览器同时访问该页面是，最极端的情况是所有 D 文件的请求被发送到同一台服务器，所以说，有可能存在这样的情况，有些服务器已经超负荷运行，而其他服务器基本是闲置的。同时，有些服务器已经忙不过来，有很长的请求列队，还不对地收到新的请求。反过来说，这会导致客户长时间的等待，觉得系统的服务质量差。</p>
<ul>
<li>简单的连接调度</li>
</ul>
<p>简单的连接调度可能会使得服务器倾斜的发生。在上面的例子中，若采用轮叫调度算法，且集群中正好有四台服务器，必有一台服务器总是收到 D 文件请求。这种调度策略会导致整合系统资源的低利用率，因为有些资源被用尽导致客户端的长时间等待，而其他资源空闲着。</p>
<ul>
<li>实际 TCP/IP 流量的特征</li>
</ul>
<p>网络流量是程波浪型发生的，在一段较长时间的小流量后，会有一端大流量的访问，然后是小流量，这样跟波浪一样周期性的发生。这就需要一个动态反馈机制，利用服务器组的状态来应对访问流的自相似性。</p>
<p>摘抄自章文嵩博士的 《Linux服务器集群系统(四)》原文链接： <a href="http://www.linuxvirtualserver.org/zh/lvs4.html" target="_blank" rel="external">http://www.linuxvirtualserver.org/zh/lvs4.html</a></p>
<p>END!</p>

    
  </div>
</article>


   

   
  <div class="box-prev-next clearfix">
    <a class="show pull-left" href="/2017/10/25/install-zabbix3-4-3-from-source/">
        <i class="icon icon-angle-left"></i>
    </a>
    <a class="show pull-right" href="/2017/10/27/lvs-load-balancing-model/">
        <i class="icon icon-angle-right"></i>
    </a>
  </div>




</div>


  <a id="backTop" class="back-top">
    <i class="icon-angle-up"></i>
  </a>




  <div class="modal" id="modal">
  <span id="cover" class="cover hide"></span>
  <div id="modal-dialog" class="modal-dialog hide-dialog">
    <div class="modal-header">
      <span id="close" class="btn-close">关闭</span>
    </div>
    <hr>
    <div class="modal-body">
      <ul class="list-toolbox">
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/archives/"
              rel="noopener noreferrer"
              target="_self"
              >
              博客
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/category/"
              rel="noopener noreferrer"
              target="_self"
              >
              分类
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/tag/"
              rel="noopener noreferrer"
              target="_self"
              >
              标签
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/link/"
              rel="noopener noreferrer"
              target="_self"
              >
              友链
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/about/"
              rel="noopener noreferrer"
              target="_self"
              >
              关于
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/search/"
              rel="noopener noreferrer"
              target="_self"
              >
              搜索
            </a>
          </li>
        
      </ul>

    </div>
  </div>
</div>



  
      <div class="fexo-comments comments-post">
    
  <section class="disqus-comments">
    <div id="disqus_thread">
      <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    </div>
  </section>

  <script>
    var disqus_shortname = 'forsigner';
    
    var disqus_url = 'http://www.weidong.io/2017/10/27/lvs-scheduling/';
    
    (function(){
      var dsq = document.createElement('script');
      dsq.type = 'text/javascript';
      dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
  </script>

  <script id="dsq-count-scr" src="//forsigner.disqus.com/count.js" async></script>



    




    

    
	
  </div>

  

  <script type="text/javascript">
  function loadScript(url, callback) {
    var script = document.createElement('script')
    script.type = 'text/javascript';

    if (script.readyState) { //IE
      script.onreadystatechange = function() {
        if (script.readyState == 'loaded' ||
          script.readyState == 'complete') {
          script.onreadystatechange = null;
          callback();
        }
      };
    } else { //Others
      script.onload = function() {
        callback();
      };
    }

    script.src = url;
    document.getElementsByTagName('head')[0].appendChild(script);
  }

  window.onload = function() {
    loadScript('/js/bundle.js?235683', function() {
      // load success
    });
  }
</script>

</body>
</html>
